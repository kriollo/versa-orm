# üõ†Ô∏è Gu√≠a del Query Builder

¬°Bienvenido al Query Builder de VersaORM! Esta es la herramienta que convierte consultas SQL complejas en c√≥digo PHP f√°cil de leer y mantener.

## ü§î ¬øQu√© es el Query Builder?

El **Query Builder** es como un "traductor inteligente" que te permite escribir consultas complejas usando m√©todos PHP encadenados en lugar de SQL complicado.

### üîÑ La Diferencia es Abismal

**‚ùå ANTES (SQL tradicional - complicado y peligroso):**
```sql
-- Consulta compleja manual
SELECT users.name, users.email, profiles.bio, COUNT(posts.id) as post_count
FROM users
LEFT JOIN profiles ON users.id = profiles.user_id
LEFT JOIN posts ON users.id = posts.user_id
WHERE users.status = 'active'
  AND users.age >= 18
  AND (users.name LIKE '%john%' OR users.email LIKE '%john%')
GROUP BY users.id, users.name, users.email, profiles.bio
HAVING COUNT(posts.id) > 5
ORDER BY users.created_at DESC, users.name ASC
LIMIT 10 OFFSET 20;

-- Problemas:
-- ‚ùå Propenso a errores de sintaxis
-- ‚ùå Dif√≠cil de leer y mantener
-- ‚ùå Vulnerable a inyecci√≥n SQL
-- ‚ùå No reutilizable
```

**‚úÖ DESPU√âS (VersaORM Query Builder - f√°cil y seguro):**
```php
// La misma consulta, pero f√°cil de leer
$users = $orm->table('users')
    ->select(['users.name', 'users.email', 'profiles.bio', 'COUNT(posts.id) as post_count'])
    ->leftJoin('profiles', 'users.id', '=', 'profiles.user_id')
    ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
    ->where('users.status', '=', 'active')
    ->where('users.age', '>=', 18)
    ->where(function($query) {
        $query->where('users.name', 'LIKE', '%john%')
              ->orWhere('users.email', 'LIKE', '%john%');
    })
    ->groupBy(['users.id', 'users.name', 'users.email', 'profiles.bio'])
    ->having('COUNT(posts.id)', '>', 5)
    ->orderBy('users.created_at', 'desc')
    ->orderBy('users.name', 'asc')
    ->limit(10)
    ->offset(20)
    ->getAll();

// Ventajas:
// ‚úÖ C√≥digo PHP natural y legible
// ‚úÖ Protecci√≥n autom√°tica contra inyecci√≥n SQL
// ‚úÖ M√©todos reutilizables y modulares
// ‚úÖ IDE con autocomplete y verificaci√≥n de tipos
```

## üöÄ Comenzando con el Query Builder

**Para empezar**, utiliza el m√©todo `table()` de tu instancia de ORM:

```php
$query = $orm->table('users'); // ¬°Este es el punto de partida!
```

---

## Obteniendo Resultados: La Diferencia Clave

Antes de ver los m√©todos de construcci√≥n, es crucial entender c√≥mo obtener los resultados. El Query Builder puede devolver los datos de dos formas distintas, dise√±adas para diferentes casos de uso:

1.  **Como Arrays (`getAll`, `firstArray`)**: Devuelve arrays asociativos de PHP. **Ideal para APIs**, respuestas JSON o cuando solo necesitas los datos sin la sobrecarga de un objeto.

2.  **Como Objetos (`findAll`, `findOne`)**: Devuelve instancias de `VersaModel`. **Ideal para l√≥gica de negocio**, donde quieres manipular los registros como objetos (p. ej., llamar a m√©todos del modelo, modificar y guardar).

| Caso de Uso                  | M√©todo Recomendado | Devuelve                               |
| ---------------------------- | ------------------ | -------------------------------------- |
| Necesito datos para una API JSON | `getAll()`         | `array` de `array`s asociativos        |
| Necesito un solo registro (API)  | `firstArray()`     | `array` asociativo o `null`            |
| Necesito objetos para manipular  | `findAll()`        | `array` de objetos `VersaModel`        |
| Necesito un solo objeto para usar | `findOne()`        | Objeto `VersaModel` o `null`           |

---

## Construcci√≥n de la Consulta

Todos los m√©todos de construcci√≥n de consultas se pueden encadenar.

### `select()` - Especificar Columnas

Por defecto, una consulta selecciona todas las columnas (`*`). Puedes especificar cu√°les necesitas con `select()`.

```php
// Seleccionar solo id, name y email
$users = $orm->table('users')
    ->select(['id', 'name', 'email'])
    ->getAll();

// Puedes usar alias
$products = $orm->table('products')
    ->select(['id', 'name as product_name'])
    ->getAll();
```

### `where()` - Cl√°usulas WHERE

#### ‚ùå Forma Tradicional (SQL)
```php
// M√∫ltiples consultas manuales
$stmt = $pdo->prepare("SELECT * FROM users WHERE status = ? AND age >= ?");
$stmt->execute(['active', 18]);
$users = $stmt->fetchAll(PDO::FETCH_ASSOC);

// Cada condici√≥n nueva = reescribir toda la consulta
$stmt = $pdo->prepare("SELECT * FROM users WHERE status = ? AND age >= ? AND city = ?");
$stmt->execute(['active', 18, 'Madrid']);
$moreUsers = $stmt->fetchAll(PDO::FETCH_ASSOC);
```

#### ‚úÖ Forma VersaORM Query Builder
```php
// Encadenamiento natural y reutilizable
$query = $orm->table('users')
    ->where('status', '=', 'active')
    ->where('age', '>=', 18);

// F√°cil agregar m√°s condiciones
$query->where('city', '=', 'Madrid');

$users = $query->findAll();

// Ventajas:
// ‚úÖ Reutilizable y modular
// ‚úÖ Sin reescribir consultas
// ‚úÖ Protecci√≥n autom√°tica SQL
// ‚úÖ C√≥digo legible
```

#### `orWhere()`

Para unir condiciones con `OR`.

```php
// WHERE status = 'active' OR is_premium = 1
$users = $orm->table('users')
    ->where('status', '=', 'active')
    ->orWhere('is_premium', '=', 1)
    ->findAll();
```

#### Otros M√©todos `where`

- `whereIn(string $column, array $values)`: Filtra si el valor de una columna est√° en un array.
- `whereNotIn(string $column, array $values)`: El opuesto a `whereIn`.
- `whereNull(string $column)`: Filtra registros donde la columna es `NULL`.
- `whereNotNull(string $column)`: Filtra registros donde la columna no es `NULL`.
- `whereBetween(string $column, $min, $max)`: Filtra registros donde el valor de una columna est√° entre `$min` y `$max`.
- `whereRaw(string $sql, array $bindings = [])`: A√±ade una condici√≥n SQL cruda. ¬°√ösalo con precauci√≥n!

**Ejemplo combinado:**

```php
$products = $orm->table('products')
    ->whereIn('category_id', [1, 2, 3])
    ->whereBetween('price', 100, 500)
    ->whereNotNull('published_at')
    ->whereRaw('stock > reserved_stock')
    ->getAll();
```

### `join()` - Unir Tablas

Puedes realizar uniones (`JOIN`) entre tablas f√°cilmente.

- `join(string $table, string $firstCol, string $operator, string $secondCol)`: `INNER JOIN`
- `leftJoin(...)`: `LEFT JOIN`
- `rightJoin(...)`: `RIGHT JOIN`

```php
// Obtener usuarios y los t√≠tulos de sus posts
$data = $orm->table('users')
    ->select(['users.name', 'posts.title as post_title'])
    ->join('posts', 'users.id', '=', 'posts.user_id')
    ->where('users.status', '=', 'active')
    ->getAll();
```

### Orden, Agrupaci√≥n y Paginaci√≥n

- `orderBy(string $column, string $direction = 'asc')`: Ordena los resultados.
- `groupBy(string|array $columns)`: Agrupa los resultados (√∫til para agregados).
- `limit(int $count)`: Limita el n√∫mero de registros devueltos.
- `offset(int $count)`: Especifica desde qu√© registro empezar (para paginaci√≥n).

**Ejemplo de paginaci√≥n:**

```php
$page = 3;
$perPage = 10;

$users = $orm->table('users')
    ->orderBy('created_at', 'desc')
    ->limit($perPage)
    ->offset(($page - 1) * $perPage)
    ->findAll();
```

---

## Carga Ansiosa (Eager Loading) con `with()`

Cuando se trabaja con relaciones de modelos (ver la gu√≠a de Modelos y Objetos), es f√°cil caer en el "problema N+1": una consulta para el modelo principal y N consultas adicionales para cargar las relaciones de cada modelo. Esto es muy ineficiente.

VersaORM soluciona esto con la **carga ansiosa** a trav√©s del m√©todo `with()`. Este m√©todo le dice al ORM que cargue las relaciones especificadas junto con la consulta principal.

**Ejemplo del problema N+1 (MALO):**
```php
// Se ejecuta 1 consulta para obtener todos los posts
$posts = Post::findAll();

// Se ejecuta 1 consulta ADICIONAL por CADA post para obtener el autor
foreach ($posts as $post) {
  echo "Autor: " . $post->user->name; // <-- ¬°Consulta aqu√≠!
}
```

**Soluci√≥n con `with()` (BUENO):**
```php
// Se ejecutan solo 2 consultas en total, sin importar cu√°ntos posts haya.
$posts = $orm->table('posts')->with('user')->findAll();

foreach ($posts as $post) {
  echo "Autor: " . $post->user->name; // <-- No hay consulta aqu√≠, los datos ya est√°n cargados.
}
```

## Funciones de Agregado

El Query Builder tambi√©n puede realizar consultas de agregado de forma eficiente.

- `count()`: Devuelve el n√∫mero de registros que coinciden con la consulta.
- `exists()`: Devuelve `true` o `false` si existen registros que coincidan.

```php
// Contar cu√°ntos usuarios inactivos hay
$inactiveCount = $orm->table('users')
    ->where('status', '=', 'inactive')
    ->count(); // Devuelve un entero, ej: 15

// Verificar si un email ya existe
$emailExists = $orm->table('users')
    ->where('email', '=', 'test@example.com')
    ->exists(); // Devuelve true o false
```

---

## Operaciones de Escritura (CRUD)

El Query Builder no es solo para leer. Tambi√©n puedes realizar operaciones de `INSERT`, `UPDATE` y `DELETE`, que son especialmente √∫tiles para operaciones en masa.

### `insert()` e `insertGetId()`

```php
// Insertar un nuevo registro
$orm->table('logs')->insert([
    'level' => 'info',
    'message' => 'User logged in',
    'context' => json_encode(['user_id' => 123])
]);

// Insertar y obtener el ID del nuevo registro
$newUserId = $orm->table('users')->insertGetId([
    'name' => 'Nuevo Usuario',
    'email' => 'nuevo@example.com'
]);
```

### `update()`

El m√©todo `update()` actualiza los registros que coincidan con las cl√°usulas `where`.

```php
// Actualizar un usuario espec√≠fico
$orm->table('users')
    ->where('id', '=', $newUserId)
    ->update(['status' => 'active']);

// Actualizar m√∫ltiples registros
// Poner todos los posts antiguos como archivados
$orm->table('posts')
    ->where('created_at', '<', '2023-01-01')
    ->update(['status' => 'archived']);
```

### `delete()`

El m√©todo `delete()` elimina los registros que coincidan con las cl√°usulas `where`.

```php
// Eliminar un usuario espec√≠fico
$orm->table('users')
    ->where('id', '=', 10)
    ->delete();

// Eliminar todos los logs de nivel 'debug'
$orm->table('logs')
    ->where('level', '=', 'debug')
    ->delete();
```

## ‚ö° Modo Lazy para M√°ximo Rendimiento

VersaORM incluye un **Modo Lazy** revolucionario que optimiza autom√°ticamente tus consultas para obtener el m√°ximo rendimiento:

```php
// Consulta normal (ejecuci√≥n inmediata)
$users = $orm->table('users')
    ->where('status', '=', 'active')
    ->where('age', '>=', 18)
    ->orderBy('created_at', 'desc')
    ->getAll();

// Consulta lazy (optimizada autom√°ticamente)
$users = $orm->table('users')
    ->lazy()                          // üöÄ Activa optimizaci√≥n autom√°tica
    ->where('status', '=', 'active')
    ->where('age', '>=', 18)
    ->orderBy('created_at', 'desc')
    ->collect();                      // ‚úÖ Ejecuta consulta optimizada
```

**Beneficios del Modo Lazy:**
- üöÄ **Consultas optimizadas autom√°ticamente**
- üß† **El planificador combina operaciones inteligentemente**
- ‚ö° **Mejor rendimiento con menos carga en la base de datos**
- üîç **Transparente**: puedes ver las optimizaciones con `explain()`

Para aprender m√°s sobre esta funcionalidad avanzada, consulta la [Gu√≠a del Modo Lazy](10-lazy-mode-query-planner.md).

---

## Siguientes Pasos

Ahora que sabes c√≥mo construir todo tipo de consultas, tienes varias opciones para profundizar:

- **[Modelos y Objetos](03-models-and-objects.md)** - Trabaja con los resultados como objetos con l√≥gica de negocio
- **[‚ö° Modo Lazy y Planificador de Consultas](10-lazy-mode-query-planner.md)** - Optimiza autom√°ticamente tus consultas para m√°ximo rendimiento
- **[Validaci√≥n y Mass Assignment](05-validation-mass-assignment.md)** - Protege tus datos al usar `update()` con el Query Builder
- **[Herramienta CLI](04-cli-tool.md)** - Aprovecha el poder del n√∫cleo Rust para operaciones avanzadas

> **üí° Tip:** Cuando uses el Query Builder para operaciones de escritura (`insert`, `update`), considera combinar tu l√≥gica con modelos personalizados que incluyan validaci√≥n autom√°tica para mayor seguridad. Para consultas complejas, el **Modo Lazy** puede mejorar significativamente el rendimiento.
